{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Preceding words As a junior student, I attempts to write down this document. On the one hand, to summarize the recent experience of learning game engine, also, it will be a part of my graduation project, on the other hand, I want to point out the general direction for future visitors. Hopefully, more and more people are willing to learn the game engine. Understand and improve it, to realize the Matrix scenes sooner. If you want to study with chinese, click here . If you have any questions when reading, please submit issue in the Github address or send email to 2481814748@qq.com . I will be very grateful for your valuable advices. Welcome to the world of game engines Why do you study Game engine is the jewel of the game's crown. The development of a game engine involves a wide range of knowledge. And even if you do not work this in the future, it's still valuable to learn. Through it, you will know how humans compress the world we live in into the engine. What will you learn I will use informations from GAMES104 and other papers, to provide enough theoretical knowledges. Also attach my VitarEngine , which developed after learning courses of Cherno after development. Please also support HazelEngine .","title":"\u5bb6"},{"location":"#preceding-words","text":"As a junior student, I attempts to write down this document. On the one hand, to summarize the recent experience of learning game engine, also, it will be a part of my graduation project, on the other hand, I want to point out the general direction for future visitors. Hopefully, more and more people are willing to learn the game engine. Understand and improve it, to realize the Matrix scenes sooner. If you want to study with chinese, click here . If you have any questions when reading, please submit issue in the Github address or send email to 2481814748@qq.com . I will be very grateful for your valuable advices.","title":"Preceding words"},{"location":"#welcome-to-the-world-of-game-engines","text":"","title":"Welcome to the world of game engines"},{"location":"#why-do-you-study","text":"Game engine is the jewel of the game's crown. The development of a game engine involves a wide range of knowledge. And even if you do not work this in the future, it's still valuable to learn. Through it, you will know how humans compress the world we live in into the engine.","title":"Why do you study"},{"location":"#what-will-you-learn","text":"I will use informations from GAMES104 and other papers, to provide enough theoretical knowledges. Also attach my VitarEngine , which developed after learning courses of Cherno after development. Please also support HazelEngine .","title":"What will you learn"},{"location":"Introduce/","text":"What is the game engine Wikipedia A game engine is a software framework primarily designed for the development of video games, and generally includes relevant libraries and support programs. The \"engine\" terminology is similar to the term \"software engine\" used in the software industry. Game engine can also refer to the development software utilizing this framework, typically offering a suite of tools and features for developing games. Developers can use game engines to construct games for video game consoles and other types of computers. The core functionality typically provided by a game engine may include a rendering engine (\"renderer\") for 2D or 3D graphics, a physics engine or collision detection (and collision response), sound, scripting, animation, artificial intelligence, networking, streaming, memory management, threading, localization support, scene graph, and video support for cinematics. Game engine implementers often economize on the process of game development by reusing/adapting, in large part, the same game engine to produce different games or to aid in porting games to multiple platforms. Dr.Wang The technological cornerstone of the Matrix; Tools to produce ideas; The art of complex systems. Zong Objectively speaking, a game engine is a collection of modules that are needed at the bottom of games. But if you think it as a complex machine or a real world, that will be a greate artwork. Respect, appreciate and understand it. The game engine will provide you with a complete development tools chain for all kinds of games, even movies. How to learn game engine The game engine contains most of the existing science knowledge, which will take you almost a whole lifetime to understand deeply. So most time, I want to talk about building the theoretical framework of the game engine with you. The rest will be filled in the future by yourself. Game engine Framework From top to bottom, they are the tools layer, the function layer, the resource layer, the platform layer and the core layer, with third-party libraries. I place the platform layer above the core layer, which means to abstract API from core codes to the platform layer and override them. Tools layer Provide developers with editor tools, such as blueprints. Function layer It is mainly through the underlying core modules to achieve the main functions required by engine development, and Tick each function module in order. Schedule and management among multithreads also belong to this layer. Resource layer It is used to record the reference relationships within or between resources and also manage the asset lifecycle. For example, when Assimp load models, a storage structure like the following will be built. Platform layer It will override the API from the core layer by different methods which depend on game platforms and rendering interfaces. Core layer Includes math library, event monitoring, logging and other core functions. Data structure and memory management also belong to this layer, by optimizing the underlying data storage to reduce memory holes. Vitar Engine In Vitar Engine , I haven't rigorously specified the directory structure as this hierarchy, but it will be organized in the near future. You can refer Piccolo Engine . However, in this document, I will try to classify articles in the same structure as above. There will be no tool layer, as it is mainly about overloading and assembling the functionality layer, while the platform layer will be introduced along with the core layer, so no new directories will be created for it. Data Sources Introduction of Assimp loading models.","title":"\u4ecb\u7ecd"},{"location":"Introduce/#what-is-the-game-engine","text":"","title":"What is the game engine"},{"location":"Introduce/#wikipedia","text":"A game engine is a software framework primarily designed for the development of video games, and generally includes relevant libraries and support programs. The \"engine\" terminology is similar to the term \"software engine\" used in the software industry. Game engine can also refer to the development software utilizing this framework, typically offering a suite of tools and features for developing games. Developers can use game engines to construct games for video game consoles and other types of computers. The core functionality typically provided by a game engine may include a rendering engine (\"renderer\") for 2D or 3D graphics, a physics engine or collision detection (and collision response), sound, scripting, animation, artificial intelligence, networking, streaming, memory management, threading, localization support, scene graph, and video support for cinematics. Game engine implementers often economize on the process of game development by reusing/adapting, in large part, the same game engine to produce different games or to aid in porting games to multiple platforms.","title":"Wikipedia"},{"location":"Introduce/#drwang","text":"The technological cornerstone of the Matrix; Tools to produce ideas; The art of complex systems.","title":"Dr.Wang"},{"location":"Introduce/#zong","text":"Objectively speaking, a game engine is a collection of modules that are needed at the bottom of games. But if you think it as a complex machine or a real world, that will be a greate artwork. Respect, appreciate and understand it. The game engine will provide you with a complete development tools chain for all kinds of games, even movies.","title":"Zong"},{"location":"Introduce/#how-to-learn-game-engine","text":"The game engine contains most of the existing science knowledge, which will take you almost a whole lifetime to understand deeply. So most time, I want to talk about building the theoretical framework of the game engine with you. The rest will be filled in the future by yourself.","title":"How to learn game engine"},{"location":"Introduce/#game-engine-framework","text":"From top to bottom, they are the tools layer, the function layer, the resource layer, the platform layer and the core layer, with third-party libraries. I place the platform layer above the core layer, which means to abstract API from core codes to the platform layer and override them.","title":"Game engine Framework"},{"location":"Introduce/#tools-layer","text":"Provide developers with editor tools, such as blueprints.","title":"Tools layer"},{"location":"Introduce/#function-layer","text":"It is mainly through the underlying core modules to achieve the main functions required by engine development, and Tick each function module in order. Schedule and management among multithreads also belong to this layer.","title":"Function layer"},{"location":"Introduce/#resource-layer","text":"It is used to record the reference relationships within or between resources and also manage the asset lifecycle. For example, when Assimp load models, a storage structure like the following will be built.","title":"Resource layer"},{"location":"Introduce/#platform-layer","text":"It will override the API from the core layer by different methods which depend on game platforms and rendering interfaces.","title":"Platform layer"},{"location":"Introduce/#core-layer","text":"Includes math library, event monitoring, logging and other core functions. Data structure and memory management also belong to this layer, by optimizing the underlying data storage to reduce memory holes.","title":"Core layer"},{"location":"Introduce/#vitar-engine","text":"In Vitar Engine , I haven't rigorously specified the directory structure as this hierarchy, but it will be organized in the near future. You can refer Piccolo Engine . However, in this document, I will try to classify articles in the same structure as above. There will be no tool layer, as it is mainly about overloading and assembling the functionality layer, while the platform layer will be introduced along with the core layer, so no new directories will be created for it.","title":"Vitar Engine"},{"location":"Introduce/#data-sources","text":"Introduction of Assimp loading models.","title":"Data Sources"},{"location":"Core/EventsSystem/","text":"Structure Advantages Application stores a pointer of Window . Window does not need to know the existence of Application . Create callback functions for Window , so Window will return a message telling Application automatically instead of asking Window from Application . Abstract Window to implement on different platforms. Event EventType \u548c EventCategory : Categorize events\u3002 enum class EventType { None = 0, WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved, AppTick, AppUpdate, AppRender, KeyPressed, KeyReleased, MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled }; enum EventCategory { None = 0, EventCategoryApplication = BIT(0), EventCategoryInput = BIT(1), EventCategoryKeyboard = BIT(2), EventCategoryMouse = BIT(3), EventCategoryMouseButton = BIT(4) }; Event : As a base class, introduces event scheduling, sets a Boolean variable to store whether the event has been handled. class HAZEL_API Event { friend class EventDispatcher; public: virtual EventType GetEventType() const = 0; virtual const char* GetName() const = 0; virtual int GetCategoryFlags() const = 0; virtual std::string ToString() const { return GetName(); } inline bool IsInCategory(EventCategory category) { return GetCategoryFlags() & category; } protected: bool m_Handled = false; }; Setting m_Handled as protected to ensure that subclasses can set and call this property directly. Through overloading and dissimilating Event , Different events can be implemented. EventDispatcher : Used to set whether the event has been processed. class EventDispatcher { template<typename T> using EventFn = std::function<bool(T&)>; public: EventDispatcher(Event& event) : m_Event(event) { } template<typename T> bool Dispatch(EventFn<T> func) { if (m_Event.GetEventType() == T::GetStaticType()) { m_Event.m_Handled = func(*(T*)&m_Event); return true; } return false; } private: Event& m_Event; }; Window WindowProps : Stores the base properties of Window . struct WindowProps { std::string Title; unsigned int Width; unsigned int Height; WindowProps(const std::string& title = \"Hazel Engine\", unsigned int width = 1280, unsigned int height = 720) : Title(title), Width(width), Height(height) { } }; Window : AS a base class, presets the event function template and specifies the window creation function. class HAZEL_API Window { public: using EventCallbackFn = std::function<void(Event&)>; virtual ~Window() {} virtual void OnUpdate() = 0; virtual unsigned int GetWidth() const = 0; virtual unsigned int GetHeight() const = 0; // Window attributes virtual void SetEventCallback(const EventCallbackFn& callback) = 0; virtual void SetVSync(bool enabled) = 0; virtual bool IsVSync() const = 0; static Window* Create(const WindowProps& props = WindowProps()); }; WindowsWindow : Overrides and implements the Window class, adds WindowData to store datas from the creation function and the current callback function, also plus settings of VSync . class WindowsWindow : public Window { public: WindowsWindow(const WindowProps& props); virtual ~WindowsWindow(); void OnUpdate() override; inline unsigned int GetWidth() const override { return m_Data.Width; } inline unsigned int GetHeight() const override { return m_Data.Height; } // Window attributes inline void SetEventCallback(const EventCallbackFn& callback) override { m_Data.EventCallback = callback; } void SetVSync(bool enabled) override; bool IsVSync() const override; private: virtual void Init(const WindowProps& props); virtual void Shutdown(); private: GLFWwindow* m_Window; struct WindowData { std::string Title; unsigned int Width, Height; bool VSync; EventCallbackFn EventCallback; }; WindowData m_Data; }; The implementation of callback functions under GLFW \u3002 // Set GLFW callbacks glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); data.Width = width; data.Height = height; WindowResizeEvent event(width, height); data.EventCallback(event); }); glfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); WindowCloseEvent event; data.EventCallback(event); }); glfwSetKeyCallback(m_Window, [](GLFWwindow* window, int key, int scancode, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { KeyPressedEvent event(key, 0); data.EventCallback(event); break; } case GLFW_RELEASE: { KeyReleasedEvent event(key); data.EventCallback(event); break; } case GLFW_REPEAT: { KeyPressedEvent event(key, 1); data.EventCallback(event); break; } } }); glfwSetMouseButtonCallback(m_Window, [](GLFWwindow* window, int button, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { MouseButtonPressedEvent event(button); data.EventCallback(event); break; } case GLFW_RELEASE: { MouseButtonReleasedEvent event(button); data.EventCallback(event); break; } } }); glfwSetScrollCallback(m_Window, [](GLFWwindow* window, double xOffset, double yOffset) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseScrolledEvent event((float)xOffset, (float)yOffset); data.EventCallback(event); }); glfwSetCursorPosCallback(m_Window, [](GLFWwindow* window, double xPos, double yPos) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseMovedEvent event((float)xPos, (float)yPos); data.EventCallback(event); }); Application Application : Adds a pointer to Window and handling function for Event \u3002 class HAZEL_API Application { public: Application(); virtual ~Application(); void Run(); void OnEvent(Event& e); private: bool OnWindowClose(WindowCloseEvent& e); std::unique_ptr<Window> m_Window; bool m_Running = true; }; Supplement knowledge #define Many macro definitions are created in game engines to simplify code, for example. #define EVENT_CLASS_TYPE(type) \\ static EventType GetStaticType() { return EventType::##type; }\\ const EventType GetEventType() const override { return GetStaticType(); }\\ const char* GetName() const override { return #type; } # converts its value into a string and ## directly concatenates characters. Create a macro of type Assert to determine whether the data is empty. #ifdef HZ_ENABLE_ASSERTS #define HAZEL_ASSERT(x, ...) if(!x) {LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #define HAZEL_CORE_ASSERT(x, ...) if(!x) {CORE_LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #else #define HAZEL_ASSERT(x, ...) #define HAZEL_CORE_ASSERT(x, ...) #endif Variadic Arguments indicates variable arguments, and __debugbreak allows the program to automatically break when running at this point. std::function Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any Callable target \u2013 functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. The stored callable object is called the target of std::function. If a std::function contains no target, it is called empty. Invoking the target of an empty std::function results in std::bad_function_call exception being thrown. std::function satisfies the requirements of CopyConstructible and CopyAssignable. Therefore, the effect of std::function can be summarized as follows. std::function encapsulates various callable entities in C++ to form a new callable std::function object; std::function objects are type-safe wraps around existing callable entities in C++ (callable entities such as function pointers are type-unsafe). You just need to convert the function to a specific function type when you call it. std::function <void()> a = static_cast<fun_ptr_a>(print); std::function <void(int)> b = static_cast<fun_ptr_b>(print); std::bind Summary The bind function can be viewed as a generic function adapter, so called an adapter, even if one thing behaves like a mechanism for another, such as a container adapter: stack , queue , priority_queue . The bind function takes a callable and generates a new callable to fit the original object. The function prototype template <class Fn, class... Args> /* unspecified */ bind (Fn&& fn, Args&&... args); The bind function takes a comma-separated list of arguments args for the given function object fn and returns a new function object. Parameters in the list args . If bound to a value, the function object returned by the call will always take that value as an argument; If is a placeholder like _n , the function object returned by the call forwards the argument passed to the call (the sequence number of the argument is specified by the placeholder). Usage std::bind is commonly used with std::function , and the return value of std::bind can be stored directly through std::function . CallBack Implementation Define a callback function; The party providing the implementation of the function registers the function pointer of the callback function to callers at the time of initialization; When a specific event or a condition occurs, the caller uses the function pointer to call the callback function to process the event. Advantages Because you can use this function to separate the caller from the callee, the caller doesn't care who the callee is. It just needs to know that there is a called function with a specific stereotype and restrictions. In short, a callback function allows a user to pass a pointer to a function that needs to be called as an argument, so that the function has the flexibility to use different methods when handling similar events. virtual In the absence of virtual , the compiler does not know much more than the base class when called with a pointer to the base class, and usually calls the base class version of the function; When a function is declared with virtual , the compiler creates a VTABLE whenever a class containing or derived from a class containing a virtual function is created; If the derived class does not redefine the virtual function of the base class, the address of the virtual function of the base class is filled in VTABLE . The compiler places a VPTR in the class that points to the corresponding VTABLE . The initialization of VPTR is done in the constructor. All the virtual functions of the parent class will be summarized into a table, and the subclass will allocate a block of memory to store the table and a pointer which points to the table. If any function is overloaded, it will overwrite the address of that function in the table. The reason why the destructor of the superclass must be virtual is to prevent running out of memory when you delete subclasses. std::unique_ptr and std::shared_ptr std::unique_ptr std::unique_ptr allows only one pointer to the same object, so the object will be destroyed automatically when the pointer is destroyed. You can change the ownership by std::move . The make_unique is recommended to create std::unique_ptr which can reduce code duplication. std::shared_ptr std::shared_ptr allows multiple Pointers to the same object with an internal counter to record the number of Pointers. You can also change ownership by std::move . The make_shared is recommended to create std::shared_ptr which can reduce code duplication. VSync Vertical synchronization aims to solve the problem that the FPS of screens and display frames are not in sync. When there are gaps, there may be Screen tearing , as shown in the following image. The graphic below shows the situation when the GPU and the display draw frame rate are out of sync. Advantages Reduce the frame rate of the GPU to match the frame rate of the monitor For some older games, the GPU frame rate will be particularly high, which is very performance consuming, and enabling Vsync will synchronize the GPU frame rate to the display frame rate, thus reducing the computation of GPU . Disadvantages Input latency may be experienced through the mouse and keyboard (commonly known as not following your hands). The interval input keyboard shown below is delayed until the next frame. Data Sources #define \u3002 std::function \u3002 std::bind \u3002 CallBack \u3002 virtual \u3002 std::make_unique unique_ptr make_shared \u3002 VSync \u3002","title":"\u4e8b\u4ef6\u7cfb\u7edf"},{"location":"Core/EventsSystem/#structure","text":"","title":"Structure"},{"location":"Core/EventsSystem/#advantages","text":"Application stores a pointer of Window . Window does not need to know the existence of Application . Create callback functions for Window , so Window will return a message telling Application automatically instead of asking Window from Application . Abstract Window to implement on different platforms.","title":"Advantages"},{"location":"Core/EventsSystem/#event","text":"EventType \u548c EventCategory : Categorize events\u3002 enum class EventType { None = 0, WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved, AppTick, AppUpdate, AppRender, KeyPressed, KeyReleased, MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled }; enum EventCategory { None = 0, EventCategoryApplication = BIT(0), EventCategoryInput = BIT(1), EventCategoryKeyboard = BIT(2), EventCategoryMouse = BIT(3), EventCategoryMouseButton = BIT(4) }; Event : As a base class, introduces event scheduling, sets a Boolean variable to store whether the event has been handled. class HAZEL_API Event { friend class EventDispatcher; public: virtual EventType GetEventType() const = 0; virtual const char* GetName() const = 0; virtual int GetCategoryFlags() const = 0; virtual std::string ToString() const { return GetName(); } inline bool IsInCategory(EventCategory category) { return GetCategoryFlags() & category; } protected: bool m_Handled = false; }; Setting m_Handled as protected to ensure that subclasses can set and call this property directly. Through overloading and dissimilating Event , Different events can be implemented. EventDispatcher : Used to set whether the event has been processed. class EventDispatcher { template<typename T> using EventFn = std::function<bool(T&)>; public: EventDispatcher(Event& event) : m_Event(event) { } template<typename T> bool Dispatch(EventFn<T> func) { if (m_Event.GetEventType() == T::GetStaticType()) { m_Event.m_Handled = func(*(T*)&m_Event); return true; } return false; } private: Event& m_Event; };","title":"Event"},{"location":"Core/EventsSystem/#window","text":"WindowProps : Stores the base properties of Window . struct WindowProps { std::string Title; unsigned int Width; unsigned int Height; WindowProps(const std::string& title = \"Hazel Engine\", unsigned int width = 1280, unsigned int height = 720) : Title(title), Width(width), Height(height) { } }; Window : AS a base class, presets the event function template and specifies the window creation function. class HAZEL_API Window { public: using EventCallbackFn = std::function<void(Event&)>; virtual ~Window() {} virtual void OnUpdate() = 0; virtual unsigned int GetWidth() const = 0; virtual unsigned int GetHeight() const = 0; // Window attributes virtual void SetEventCallback(const EventCallbackFn& callback) = 0; virtual void SetVSync(bool enabled) = 0; virtual bool IsVSync() const = 0; static Window* Create(const WindowProps& props = WindowProps()); }; WindowsWindow : Overrides and implements the Window class, adds WindowData to store datas from the creation function and the current callback function, also plus settings of VSync . class WindowsWindow : public Window { public: WindowsWindow(const WindowProps& props); virtual ~WindowsWindow(); void OnUpdate() override; inline unsigned int GetWidth() const override { return m_Data.Width; } inline unsigned int GetHeight() const override { return m_Data.Height; } // Window attributes inline void SetEventCallback(const EventCallbackFn& callback) override { m_Data.EventCallback = callback; } void SetVSync(bool enabled) override; bool IsVSync() const override; private: virtual void Init(const WindowProps& props); virtual void Shutdown(); private: GLFWwindow* m_Window; struct WindowData { std::string Title; unsigned int Width, Height; bool VSync; EventCallbackFn EventCallback; }; WindowData m_Data; }; The implementation of callback functions under GLFW \u3002 // Set GLFW callbacks glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); data.Width = width; data.Height = height; WindowResizeEvent event(width, height); data.EventCallback(event); }); glfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); WindowCloseEvent event; data.EventCallback(event); }); glfwSetKeyCallback(m_Window, [](GLFWwindow* window, int key, int scancode, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { KeyPressedEvent event(key, 0); data.EventCallback(event); break; } case GLFW_RELEASE: { KeyReleasedEvent event(key); data.EventCallback(event); break; } case GLFW_REPEAT: { KeyPressedEvent event(key, 1); data.EventCallback(event); break; } } }); glfwSetMouseButtonCallback(m_Window, [](GLFWwindow* window, int button, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { MouseButtonPressedEvent event(button); data.EventCallback(event); break; } case GLFW_RELEASE: { MouseButtonReleasedEvent event(button); data.EventCallback(event); break; } } }); glfwSetScrollCallback(m_Window, [](GLFWwindow* window, double xOffset, double yOffset) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseScrolledEvent event((float)xOffset, (float)yOffset); data.EventCallback(event); }); glfwSetCursorPosCallback(m_Window, [](GLFWwindow* window, double xPos, double yPos) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseMovedEvent event((float)xPos, (float)yPos); data.EventCallback(event); });","title":"Window"},{"location":"Core/EventsSystem/#application","text":"Application : Adds a pointer to Window and handling function for Event \u3002 class HAZEL_API Application { public: Application(); virtual ~Application(); void Run(); void OnEvent(Event& e); private: bool OnWindowClose(WindowCloseEvent& e); std::unique_ptr<Window> m_Window; bool m_Running = true; };","title":"Application"},{"location":"Core/EventsSystem/#supplement-knowledge","text":"","title":"Supplement knowledge"},{"location":"Core/EventsSystem/#define","text":"Many macro definitions are created in game engines to simplify code, for example. #define EVENT_CLASS_TYPE(type) \\ static EventType GetStaticType() { return EventType::##type; }\\ const EventType GetEventType() const override { return GetStaticType(); }\\ const char* GetName() const override { return #type; } # converts its value into a string and ## directly concatenates characters. Create a macro of type Assert to determine whether the data is empty. #ifdef HZ_ENABLE_ASSERTS #define HAZEL_ASSERT(x, ...) if(!x) {LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #define HAZEL_CORE_ASSERT(x, ...) if(!x) {CORE_LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #else #define HAZEL_ASSERT(x, ...) #define HAZEL_CORE_ASSERT(x, ...) #endif Variadic Arguments indicates variable arguments, and __debugbreak allows the program to automatically break when running at this point.","title":"#define"},{"location":"Core/EventsSystem/#stdfunction","text":"Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any Callable target \u2013 functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. The stored callable object is called the target of std::function. If a std::function contains no target, it is called empty. Invoking the target of an empty std::function results in std::bad_function_call exception being thrown. std::function satisfies the requirements of CopyConstructible and CopyAssignable. Therefore, the effect of std::function can be summarized as follows. std::function encapsulates various callable entities in C++ to form a new callable std::function object; std::function objects are type-safe wraps around existing callable entities in C++ (callable entities such as function pointers are type-unsafe). You just need to convert the function to a specific function type when you call it. std::function <void()> a = static_cast<fun_ptr_a>(print); std::function <void(int)> b = static_cast<fun_ptr_b>(print);","title":"std::function"},{"location":"Core/EventsSystem/#stdbind","text":"","title":"std::bind"},{"location":"Core/EventsSystem/#summary","text":"The bind function can be viewed as a generic function adapter, so called an adapter, even if one thing behaves like a mechanism for another, such as a container adapter: stack , queue , priority_queue . The bind function takes a callable and generates a new callable to fit the original object.","title":"Summary"},{"location":"Core/EventsSystem/#the-function-prototype","text":"template <class Fn, class... Args> /* unspecified */ bind (Fn&& fn, Args&&... args); The bind function takes a comma-separated list of arguments args for the given function object fn and returns a new function object. Parameters in the list args . If bound to a value, the function object returned by the call will always take that value as an argument; If is a placeholder like _n , the function object returned by the call forwards the argument passed to the call (the sequence number of the argument is specified by the placeholder).","title":"The function prototype"},{"location":"Core/EventsSystem/#usage","text":"std::bind is commonly used with std::function , and the return value of std::bind can be stored directly through std::function .","title":"Usage"},{"location":"Core/EventsSystem/#callback","text":"","title":"CallBack"},{"location":"Core/EventsSystem/#implementation","text":"Define a callback function; The party providing the implementation of the function registers the function pointer of the callback function to callers at the time of initialization; When a specific event or a condition occurs, the caller uses the function pointer to call the callback function to process the event.","title":"Implementation"},{"location":"Core/EventsSystem/#advantages_1","text":"Because you can use this function to separate the caller from the callee, the caller doesn't care who the callee is. It just needs to know that there is a called function with a specific stereotype and restrictions. In short, a callback function allows a user to pass a pointer to a function that needs to be called as an argument, so that the function has the flexibility to use different methods when handling similar events.","title":"Advantages"},{"location":"Core/EventsSystem/#virtual","text":"In the absence of virtual , the compiler does not know much more than the base class when called with a pointer to the base class, and usually calls the base class version of the function; When a function is declared with virtual , the compiler creates a VTABLE whenever a class containing or derived from a class containing a virtual function is created; If the derived class does not redefine the virtual function of the base class, the address of the virtual function of the base class is filled in VTABLE . The compiler places a VPTR in the class that points to the corresponding VTABLE . The initialization of VPTR is done in the constructor. All the virtual functions of the parent class will be summarized into a table, and the subclass will allocate a block of memory to store the table and a pointer which points to the table. If any function is overloaded, it will overwrite the address of that function in the table. The reason why the destructor of the superclass must be virtual is to prevent running out of memory when you delete subclasses.","title":"virtual"},{"location":"Core/EventsSystem/#stdunique_ptr-and-stdshared_ptr","text":"","title":"std::unique_ptr and std::shared_ptr"},{"location":"Core/EventsSystem/#stdunique_ptr","text":"std::unique_ptr allows only one pointer to the same object, so the object will be destroyed automatically when the pointer is destroyed. You can change the ownership by std::move . The make_unique is recommended to create std::unique_ptr which can reduce code duplication.","title":"std::unique_ptr"},{"location":"Core/EventsSystem/#stdshared_ptr","text":"std::shared_ptr allows multiple Pointers to the same object with an internal counter to record the number of Pointers. You can also change ownership by std::move . The make_shared is recommended to create std::shared_ptr which can reduce code duplication.","title":"std::shared_ptr"},{"location":"Core/EventsSystem/#vsync","text":"Vertical synchronization aims to solve the problem that the FPS of screens and display frames are not in sync. When there are gaps, there may be Screen tearing , as shown in the following image. The graphic below shows the situation when the GPU and the display draw frame rate are out of sync.","title":"VSync"},{"location":"Core/EventsSystem/#advantages_2","text":"Reduce the frame rate of the GPU to match the frame rate of the monitor For some older games, the GPU frame rate will be particularly high, which is very performance consuming, and enabling Vsync will synchronize the GPU frame rate to the display frame rate, thus reducing the computation of GPU .","title":"Advantages"},{"location":"Core/EventsSystem/#disadvantages","text":"Input latency may be experienced through the mouse and keyboard (commonly known as not following your hands). The interval input keyboard shown below is delayed until the next frame.","title":"Disadvantages"},{"location":"Core/EventsSystem/#data-sources","text":"#define \u3002 std::function \u3002 std::bind \u3002 CallBack \u3002 virtual \u3002 std::make_unique unique_ptr make_shared \u3002 VSync \u3002","title":"Data Sources"},{"location":"Core/InputPolling/","text":"Structure Advantages Functions are overloaded on different platforms and then called by standard functions. Input Input : As a base class, it provides a public standard function interface which is easy to call and an implementation function interface which will be overloaded. class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; }; WindowsInput WindowsInput : The implementation function is overloaded with GLFW . class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; }; Supplement knowledge static Objects that are modified by static in their parent class do not will change their access after inheriting. Data Sources static \u3002","title":"\u8f93\u5165\u6c60"},{"location":"Core/InputPolling/#structure","text":"","title":"Structure"},{"location":"Core/InputPolling/#advantages","text":"Functions are overloaded on different platforms and then called by standard functions.","title":"Advantages"},{"location":"Core/InputPolling/#input","text":"Input : As a base class, it provides a public standard function interface which is easy to call and an implementation function interface which will be overloaded. class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; };","title":"Input"},{"location":"Core/InputPolling/#windowsinput","text":"WindowsInput : The implementation function is overloaded with GLFW . class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; };","title":"WindowsInput"},{"location":"Core/InputPolling/#supplement-knowledge","text":"","title":"Supplement knowledge"},{"location":"Core/InputPolling/#static","text":"Objects that are modified by static in their parent class do not will change their access after inheriting.","title":"static"},{"location":"Core/InputPolling/#data-sources","text":"static \u3002","title":"Data Sources"},{"location":"Core/LayersSystem/","text":"Usage Different contents are assigned to different layers and then output them to the screen in a specific rendering order. Structure Advantages Achieve hierarchical management. Layer Layer : As a base class, it contains the basic functionality required by the layer (events listening and contents updating). class HAZEL_API Layer { public: Layer(const std::string& name = \"Layer\"); virtual ~Layer(); virtual void OnAttach() {} virtual void OnDetach() {} virtual void OnUpdate() {} virtual void OnEvent(Event& event) {} inline const std::string& GetName() const { return m_DebugName; } protected: std::string m_DebugName; }; LayerStack LayerStack : Storage and manage all layers. class HAZEL_API LayerStack { public: LayerStack(); ~LayerStack(); void PushLayer(Layer* layer); void PushOverlay(Layer* overlay); void PopLayer(Layer* layer); void PopOverlay(Layer* overlay); std::vector<Layer*>::iterator begin() { return m_Layers.begin(); } std::vector<Layer*>::iterator end() { return m_Layers.end(); } private: std::vector<Layer*> m_Layers; std::vector<Layer*>::iterator m_LayerInsert; }; The topmost layer receives events first and is rendered at the last (it will overwrite the other layers).","title":"\u5c42\u7ea7\u7cfb\u7edf"},{"location":"Core/LayersSystem/#usage","text":"Different contents are assigned to different layers and then output them to the screen in a specific rendering order.","title":"Usage"},{"location":"Core/LayersSystem/#structure","text":"","title":"Structure"},{"location":"Core/LayersSystem/#advantages","text":"Achieve hierarchical management.","title":"Advantages"},{"location":"Core/LayersSystem/#layer","text":"Layer : As a base class, it contains the basic functionality required by the layer (events listening and contents updating). class HAZEL_API Layer { public: Layer(const std::string& name = \"Layer\"); virtual ~Layer(); virtual void OnAttach() {} virtual void OnDetach() {} virtual void OnUpdate() {} virtual void OnEvent(Event& event) {} inline const std::string& GetName() const { return m_DebugName; } protected: std::string m_DebugName; };","title":"Layer"},{"location":"Core/LayersSystem/#layerstack","text":"LayerStack : Storage and manage all layers. class HAZEL_API LayerStack { public: LayerStack(); ~LayerStack(); void PushLayer(Layer* layer); void PushOverlay(Layer* overlay); void PopLayer(Layer* layer); void PopOverlay(Layer* overlay); std::vector<Layer*>::iterator begin() { return m_Layers.begin(); } std::vector<Layer*>::iterator end() { return m_Layers.end(); } private: std::vector<Layer*> m_Layers; std::vector<Layer*>::iterator m_LayerInsert; }; The topmost layer receives events first and is rendered at the last (it will overwrite the other layers).","title":"LayerStack"},{"location":"Core/Math/","text":"Structure glm is used as the math library.","title":"\u6570\u5b66"},{"location":"Core/Math/#structure","text":"glm is used as the math library.","title":"Structure"},{"location":"Function/ImGuiLayer/","text":"Build ImGuiLayer : Inherits from Layer \u3002 class HAZEL_API ImGuiLayer : public Layer { public: ImGuiLayer(); ~ImGuiLayer(); void OnAttach(); void OnDetach(); void OnUpdate(); void OnEvent(Event& event); private: float m_Time = 0.0f; }; Usage Just add the following codes to the editor, you will get a small window named Test . ImGui::Begin(\"Test\"); ImGui::Text(\"Hello World\"); ImGui::End();","title":"ImGui \u5c42"},{"location":"Function/ImGuiLayer/#build","text":"ImGuiLayer : Inherits from Layer \u3002 class HAZEL_API ImGuiLayer : public Layer { public: ImGuiLayer(); ~ImGuiLayer(); void OnAttach(); void OnDetach(); void OnUpdate(); void OnEvent(Event& event); private: float m_Time = 0.0f; };","title":"Build"},{"location":"Function/ImGuiLayer/#usage","text":"Just add the following codes to the editor, you will get a small window named Test . ImGui::Begin(\"Test\"); ImGui::Text(\"Hello World\"); ImGui::End();","title":"Usage"}]}